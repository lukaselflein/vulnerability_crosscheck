import json
import pandas as pd
import numpy as np
import urllib.request
import gzip
import os
import csv


def download_json():
    earliest_year = 2019
    latest_year = 2020

    file_paths = []
    skipped_files = 0
    for year in range(earliest_year, latest_year + 1):
        file_name = "nvdcve-1.1-{}.json".format(year)
        db_folder = "./data"
        file_path = os.path.join(db_folder, file_name)
        compressed_file_name = file_name + '.gz'
        compressed_file_path = os.path.join(db_folder, compressed_file_name)

        if not os.path.isdir(db_folder):
            os.mkdir(db_folder)

        # Only download if not already at rest
        if not os.path.isfile(file_path):
            # Download the vulnerabilty database (NVD)
            url = "https://nvd.nist.gov/feeds/json/cve/1.1/{}.gz".format(file_name)
            print('Downloading {}'.format(url))
            response = urllib.request.urlretrieve(url, compressed_file_path)
            print('Response: {}'.format(response))

            # Extract the gzip
            with gzip.GzipFile(compressed_file_path, 'rb') as infile:
                s = infile.read()

            # Save extracted file
            with open(file_path, 'wb') as outfile:
                outfile.write(s)
            file_paths += [file_path]
        else:
            skipped_files += 1

    print('{} files already on disk (download skipped)'.format(skipped_files))

    return file_paths

def extract_table(file_path="./data/nvdcve-1.1-2020.json"):
    # Open the .json file
    with open(file_path, "r") as cve_json:
        cve_dict = json.load(cve_json)
    cve_dict.keys()

    # We will write all items into a flat list, which will be upgraded to a pandas DataFrame later
    vul_list = []

    # We iterate over all CVE ids
    nr_cve_items = len(cve_dict['CVE_Items'])
    print("Total CVEs: \t{}".format(nr_cve_items))

    for cve_index in range(nr_cve_items):
        # Extract the CVE number of the vulnerability

        cve_id = cve_dict['CVE_Items'][cve_index]['cve']['CVE_data_meta']['ID'] 
        description = cve_dict['CVE_Items'][cve_index]['cve']['description']['description_data'][0]['value']
        published_date = cve_dict['CVE_Items'][cve_index]['publishedDate']
        # Extract the score if available
        try:
            cve_score = cve_dict['CVE_Items'][cve_index]['impact']['baseMetricV3']['cvssV3']['baseScore']
        except:
            cve_score = np.NaN

        
        # Not every CVE id has a machine-readable config (cpe_match) entry.
        # Supress exceptions with try.. except      
        i = 0
        try:
            entries = cve_dict['CVE_Items'][cve_index]['configurations']['nodes']
            for config_index in range(len(entries)):
                versions = set()
                
                # Extract list of all vulnerable configurations (for 'OR' connector)
                vulnerable_configs = []
                if entries[config_index]['operator'] == 'OR':
                    for cpe in entries[0]['cpe_match']:
                        if cpe['vulnerable'] is True:
                            try:
                                max_vers = cpe['versionEndExcluding']
                            except:
                                max_vers = None
                            # aCPE string
                            cpe_string = cpe['cpe23Uri']
                            vulnerable_configs += [(cpe_string,  max_vers)]               
                            
                else:
                    for config in entries:
                        for cpe in config['children'][0]['cpe_match']:
                            if cpe['vulnerable'] is True:
                                try:
                                    max_vers = cpe['versionEndExcluding']
                                except:
                                    max_vers = None
                                # aCPE string
                                cpe_string = cpe['cpe23Uri']
                                vulnerable_configs += [(cpe_string,  max_vers)]
                
                # Remove duplicates
                unique_vulnerable_configs = list(dict.fromkeys(vulnerable_configs))
                
                for cpe, max_vers in unique_vulnerable_configs:
                    vendor = cpe.split(':')[3]
                    name = cpe.split(':')[4]
                    version = cpe.split(':')[5]
                    if version == '*':
                        if max_vers is not None:
                            version = max_vers
                    versions.add(version)
                    
                versions_string = '|'.join(versions)
                vul_list += [[cve_id, vendor, name, versions_string, 
                              description, cve_score, published_date]]  
                    
        # Put in NaN in for name, version, vendor if unavailable in machine-readable cpe entries
        except:
            vendor = np.NaN
            name = np.NaN
            version = np.NaN
            vul_list += [[cve_id, vendor, name, version, description, cve_score]]    

    return vul_list

def print_stats(vul_list):
    # Print some stats
    print("Unique Vers: \t{} ({:1.0f}%)".format(len(vul_list), len(vul_list)/nr_cve_items*100))

    missing_values = 0
    incomplete_entries = 0
    for entry in vul_list:
        a = entry.count('*')
        a += entry.count(np.NaN)
        if a > 0:
            incomplete_entries += 1
        missing_values += a

    print("Incomplete:\t{} ({:1.0f}%)".format(incomplete_entries, incomplete_entries/len(vul_list)*100))


def export_csv(vul_list, file_path):
    csv_string = "cve_id, vendor, name, versions_string, description, cve_score, published_date\n"
    for line in vul_list:
        line_string = ""
        for entry in line:
            line_string += '"' + str(entry) + '"' + ", "
        line_string += "\n"
        csv_string += line_string

    with open(file_path, 'w') as outfile:
        outfile.write(csv_string)

    return csv_string


if __name__ == '__main__':
    file_paths = download_json()
    print(file_paths)
    json_path="./data/nvdcve-1.1-2020.json"
    vul_list = extract_table(file_path=json_path)
    csv_path = json_path.replace("json", "csv")
    export_csv(vul_list, file_path=csv_path)

